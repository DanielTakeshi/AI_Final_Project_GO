import structure5.Vector;
import java.util.Random;

// FFTree for playing go
/*
  


ublic interface IBox
{
   public void setSize(int size);
   public int getSize();
   public int getArea();
  //...and so on
}
 */


public class GoTree implements GoTreeInterface {
    // input, hidden, and output num are the node counts for each layer
    int inputNum;
    int hiddenNum;
    int outputNum;

    // mew is the learning rate
    double mew;

    // the hidden weight vector holds the weight array i for hidden node i for all input nodes
    // the hidden Output and hidden error are for feed forward and backwards, where they hold intermediate values
    Vector<Double[]> hiddenWeight;
    Double[] hiddenOutput;
    Double[] hiddenError;
    
    // the output weight, array, and error serve the same purpose for the 
    Vector<Double[]> outputWeight;
    Double[] outputArray;
    Double[] outputError;

    int[] inputArray;
    int[] targetArray;

    Vector<AttributeController> attrVector;
    AttributeController targetController;
    
    public GoTree(int hiddenIn, double mewIn, int inputIn, int outputIn){
	//store input values
	hiddenNum = hiddenIn;
	mew = mewIn;
	inputNum = inputIn;
	outputNum = outputIn;
	attrVector = attrIn;
	targetController = attrVector.lastElement();

	//initialize weight vectors for each hidden node
	//at the same time, initialize hidden ouput arrays
	hiddenWeight = new Vector<Double[]>(hiddenNum);
	hiddenOutput = new Double[hiddenNum];
	hiddenError = new Double[hiddenNum];

	Random rando = new Random();

	for(int i = 0; i < hiddenNum; i++){
	    Double[] outputArray = new Double[outputNum];
	    //initialize each weight array to have values between -.5 and .5
	    Double[] weightArray = new Double[inputNum];
	    for(int p = 0; p < inputNum; p++){
		weightArray[p] = rando.nextDouble() - 0.5;
	    }
	    //store in Vector at index of hidden node
	    hiddenWeight.add(i, weightArray);
	}

	inputArray = new int[inputNum];
	targetArray = new int[outputNum];

	outputArray = new Double[outputNum];
	outputError = new Double[outputNum];

	//initialize weight vectors for each output node
	outputWeight = new Vector<Double[]>(outputNum);

	for(int i = 0; i < outputNum; i++){
	    Double[] tempArray = new Double[hiddenNum];

	    for(int p = 0; p < hiddenNum; p++){
		tempArray[p] = rando.nextDouble() - 0.5;
	    }

	    //store in Vector at index of output node
	    outputWeight.add(i, tempArray);
	}
	//initialization is complete
    }

    public void train(String[] example){
	//call propagateForward -- common to test
	this.propagateForward(example);

	//set target array using target attribute controller
	targetController.setInput(example[example.length - 1], targetArray);

	//propagate errors backward through tree
	this.propagateBackward();

	//update tree
	this.update();
    }

    private void propagateForward(String[] example){
	//propagate input to hidden nodes:
	//set inputs

	for(int i = 0; i < example.length - 1; i++){
	    attrVector.get(i).setInput(example[i].trim(), inputArray);
	}

	//for each hidden node:
	for(int i = 0; i < hiddenNum; i++){
	    //operating on a single hidden node
	    Double[] tempWeight = hiddenWeight.get(i);
	    //sum over inputs x_i*w_i
	    double net = 0.0;

	    for(int p = 0; p < inputNum; p++){
		net += ((double) inputArray[p]) * tempWeight[p];
	    }

	    //perform sigmoid function
	    net = 1/(1 + (Math.exp(-net)));
	    //store net into output vector
	    hiddenOutput[i] = net;
	}	

	//propagate hidden output to output nodes:
	//for each output node:

	for(int i = 0; i < outputNum; i++){
	    //operating on a single output node
	    Double[] tempWeight = outputWeight.get(i);
	    //sum over inputs x_i*w_i
	    double net = 0.0;
	    for(int p = 0; p < hiddenNum; p++){
		net += hiddenOutput[p] * tempWeight[p];
	    }
	    //perform sigmoid function
	    net  = 1/(1 + (Math.exp(-net)));
	    //store net into output vector
	    outputArray[i] = net;
	}
    }

    private void propagateBackward(){
	//calculate error on each output unit
	double output;
	double target;
	double error;

	for(int i = 0; i < outputNum; i++){
	    //retrieve output and target
	    output = outputArray[i];
	    target = (double) targetArray[i];
	    //calculate error;
	    error = output * (1.0 - output) * (target - output);
	    //store into error vector for output node
	    outputError[i] = error;
	}

	//calculate error on each hidden unit
	double sum;
	double weight;

	for(int i = 0; i < hiddenNum; i++){
	    sum = 0.0;
	    for(int p = 0; p < outputNum; p++){
		//sum error over all outputs: w_pi * error_p
		//where pi is the weight for output node p to hidden node i
		error = outputError[p];
		//this call is expensive and slow
		weight = (outputWeight.get(p))[i];
		sum += weight * error;
	    }
	    //store sum * output * (1- output) into error for hidden node i
	    hiddenError[i] = sum * hiddenOutput[i] * (1 - hiddenOutput[i]);
	}
    }

    private void update(){
	//call to update edge weights for every hidden node and every output node
	Double[] tempArray;
	int input;
	double error;
	//update hidden node weights

	for(int i = 0; i < hiddenNum; i++){
	    //operating on a single hidden node, and its edge weights
	    tempArray = hiddenWeight.get(i);
	    error = hiddenError[i];

	    for(int p = 0; p < inputNum; p++){
		//want to store into w_pi = w_pi + mew * error_i * input_p
		tempArray[p] += mew * error * ((double) inputArray[p]);
	    }
	}

	double hiddenInput;
	//update output node weights

	for(int i = 0; i < outputNum; i++){
	    //operating on a single output node, and its edge weights
	    tempArray = outputWeight.get(i);
	    error = outputError[i];

	    for(int p = 0; p < hiddenNum; p++){
		//want to store into w_pi = w_pi + mew * error_i * input_p
		tempArray[p] += mew * error * hiddenOutput[p];
	    }
	}
    }

    public int test(String[] example){
	//propagate example through the tree
	this.propagateForward(example);		

	//find highest-valued output
	double result = 0.0;
	int resultIndex = 0;

	for(int i = 0; i < outputNum; i++){

	    if(outputArray[i] > result){
		result = outputArray[i];
		resultIndex = i;
	    }
	}
	return resultIndex;
    }
}